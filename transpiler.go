package main

import (
	"bufio"
	"fmt"
	"strings"
	"time"
)

type Transpiler struct {
	source string
	output strings.Builder
}

func NewTranspiler(source string) *Transpiler {
	return &Transpiler{
		source: source,
	}
}

/*
	 func (t *Transpiler) generateHeader() {
		t.output.WriteString("// Generated by Blaze Transpiler\n")
		t.output.WriteString(fmt.Sprintf("// Current Date and Time (UTC): %s\n", time.Now().UTC().Format("2006-01-02 15:04:05")))
		t.output.WriteString("package main\n\n")

}
*/
func (t *Transpiler) processLine(line string) string {

	if strings.HasPrefix(line, "print(") {
		content := line[6 : len(line)-1]
		return fmt.Sprintf("fmt.Print(%s", content)
	}
	if strings.HasPrefix(line, "println(") {
		content := line[8 : len(line)-1]
		return fmt.Sprintf("fmt.Println(%s", content)
	}
	if strings.HasPrefix(line, "printf(") {
		content := line[7 : len(line)-1]
		return fmt.Sprintf("fmt.Printf(%s", content)
	}
	isDebug := strings.HasSuffix(line, "?")
	line = strings.TrimSpace(strings.TrimSuffix(strings.TrimSuffix(line, "!"), "?"))

	if strings.HasPrefix(line, "let ") {
		return "var " + strings.TrimPrefix(line, "let ")
	}

	// Process the line
	line = strings.ReplaceAll(line, "::", ".")
	line = strings.ReplaceAll(line, ";", "!")
	line = strings.ReplaceAll(line, "[", "{")
	line = strings.ReplaceAll(line, "]", "}")
	line = strings.ReplaceAll(line, "$=", ":=")

	// Handle imports
	if strings.HasPrefix(line, "import ") {
		importPath := strings.TrimPrefix(line, "import ")
		return fmt.Sprintf("\t\"%s\"", importPath)
	}

	// Handle := assignments with debug
	if idx := strings.Index(line, ":="); idx >= 0 {
		beforeAssignment := strings.TrimSpace(line[:idx])
		afterAssignment := strings.TrimSpace(line[idx+2:])

		if strings.Contains(afterAssignment, "(") && strings.Contains(afterAssignment, ")") {
			vars := strings.Split(beforeAssignment, ",")
			if len(vars) == 1 {
				line = strings.Replace(line, ":=", ", err :=", 1)
				if isDebug {
					// For assignments, print the variables after assignment
					return fmt.Sprintf("%s\n\tfmt.Printf(\"Debug: %%+v, err: %%v\\n\", %s, err)",
						line, strings.TrimSpace(vars[0]))
				}
			}
		} else if isDebug {
			// For simple assignments
			return fmt.Sprintf("%s\n\tfmt.Printf(\"Debug: %%+v\\n\", %s)",
				line, beforeAssignment)
		}
	}

	// For non-assignment debug lines
	if isDebug {
		return fmt.Sprintf("%s\n\tfmt.Printf(\"Debug: %%+v\\n\", %s)", line, line)
	}

	return line
}
func (t *Transpiler) Transpile() string {
	t.output.WriteString("// Generated by Blaze Transpiler\n")
	t.output.WriteString(fmt.Sprintf("// Current Date and Time (UTC): %s\n", time.Now().UTC().Format("2006-01-02 15:04:05")))
	t.output.WriteString("package main\n\n")

	// Create a buffer for imports
	var imports strings.Builder
	imports.WriteString("import (\n")
	imports.WriteString("\t\"fmt\"\n")
	// First pass - collect imports
	scanner := bufio.NewScanner(strings.NewReader(t.source))
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if strings.HasPrefix(line, "import ") {
			processed := t.processLine(line)
			imports.WriteString(processed + "\n")
		}
	}
	imports.WriteString(")\n\n")

	// Write imports section if any imports were found
	t.output.WriteString(imports.String())

	// Second pass - process the rest of the code
	t.output.WriteString("func main() {\n")
	scanner = bufio.NewScanner(strings.NewReader(t.source))
	for scanner.Scan() {

		line := strings.TrimSpace(scanner.Text())
		line = strings.ReplaceAll(line, "[", "{")
		line = strings.ReplaceAll(line, "]", "}")

		if line == "" {
			continue // Skip empty lines
		}

		if strings.HasPrefix(line, "import ") {
			continue // Skip imports in main()
		}

		if line == "try {" {
			t.output.WriteString("\tvar err error\n")
			continue
		}

		if line == "} catch err {" {
			t.output.WriteString("\tif err != nil {\n")
			continue
		}

		if line == "{" {
			t.output.WriteString("\t}\n")
			continue
		}

		processedLine := t.processLine(line)
		if processedLine != "" {
			t.output.WriteString("\t" + processedLine + "\n")
		}
	}

	t.output.WriteString("}\n")
	return t.output.String()
}
